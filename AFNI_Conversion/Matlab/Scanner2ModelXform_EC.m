%function [] = Scanner2ModelXform_EC(wd,f_aligned, f_unaligned, DTfname)
% This function computes/applies the transformation between DT-MR scanner 
% and geometric model coordinate frames. Since DT-MR is usually of lower 
% resolution than anatomical CT/MR scans, a geometric model is typically 
% constructed from the latter, and fiber information of the same heart but
% separate DT-MR scan is co-registered to the model in the simulation
% reference frame
%
% INPUTS:
% 1. data_group+data_sub_group+main_dir, - file path to working directory containing files below.
% 2. f_unaligned - OFF file containing (n_dat)x(3) point-cloud of 
%    coordinates in the anatomical scan reference frame
% 3. f_aligned - OFF file containing (n_dat)x(3) point-cloud of 
%    coordinates rotated to the model reference frame
% 4. DTfname - Matlab workspace containing variables DT and coords
%    generated by running Parse_AFNI_v3.m
% 5. figyn - 1 to show figures, 0 to not. Default is 0.
%
% OUTPUTS:
% 1. coords_r - (n_DTdat)x(3) array of DT-MR voxel coordinates 
%    rotated/co-registerd to anatomical model in model reference frame
% 3. DT_rl  - (n_DTdat)x(3)x(3) array of rotated matrix-log diffusion 
%    tensors in model reference frame
%
% Make sure to check that all input coordinates have CONSISTENT UNITS to 
% avoid scaling artifacts!
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Originally written by Chris Villongco
% Edited by Eric Carruth on 03/03/2017
% Last modified by Eric Carruth on 03/21/2017
% Contact: ecarruth@ucsd.edu OR kappyt3@gmail.com
% -------------------------------------------------------------------------
% Modified by: Daya Kern
% Last Edited: 13 October, 2017
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [] = Scanner2ModelXform_EC(working_directory, f_aligned, f_unaligned, DTfname)
    wd = [working_directory];
    
    % Determine if figures should be displayed
    figyn = 0;
    
    % Read in the initial and aligned data sets
    % Initial
    fid = fopen([wd f_unaligned],'r');
    ln0 = textscan(fid,'%s\n',1);
    ln1 = textscan(fid,'%d\t%d\t%d\n',1);
    npts_o = ln1{1};
    init = textscan(fid,'%f\t%f\t%f\n',npts_o);
    fclose(fid);
    % Aligned
    fid = fopen([wd f_aligned],'r');
    ln0 = textscan(fid,'%s\n',1);
    ln1 = textscan(fid,'%d\t%d\t%d\n',1);
    npts_a = ln1{1};
    alin = textscan(fid,'%f\t%f\t%f\n',npts_a);
    fclose(fid);

    init = cell2mat(init);
    alin = cell2mat(alin);

    % Load the mat file
    fprintf('Loading file... ');
    tic;
    dTMatFile = matfile([wd DTfname]); 
    fprintf('Done.\n');
    toc;

    % Get diffusion tensor data from DT mat file
    DT = dTMatFile.DT;
    % Get coordinate data from DT mat file
    coords = dTMatFile.coords;

    % Make sure they have the same number of vertices
    if npts_o ~= npts_a
        error('The two input files have a different number of vertices!');
    end

    % Number of data points
    n_dat = length(coords);

    % Additional translation tweaks in blender to align DTMRI data to MRI data
    % used for geometric fit
    Tadj = ones(n_dat,1)*[0 0 0 0];

    % Compute 4x4 transformation T
    % Reference: http://www.euclideanspace.com/maths/geometry/affine/matrix4x4/
    init(:,4) = 1;
    alin(:,4) = 1;
    T = (init'*init)\init'*alin;
    fprintf('4x4 affine transformation matrix:\n');
    disp(T);

    % Extract rotation matrix from T
    C = T(1:3,1:3);
    fprintf('Tensor rotation matrix C:\n');
    disp(C);

    % Check that rotation does not include scaling. (det(C) should equal 1!)
    fprintf('Determinant of C:\n');
    disp(det(C));

    % Apply transformation to coordinates
    coords_temp = coords;
    coords_temp(:,4) = 1;
    coords_r = coords_temp*T + Tadj;
    coords_r(:,4) = [];

    % Show plots of original and rotated segmentation and coords
    if figyn
        figure;
        plot3(coords(1:100:end,1),coords(1:100:end,2),coords(1:100:end,3), ...
            'bo','Markersize', 12, 'MarkerFaceColor', [0 0 0.4]); hold on;
        plot3(init(1:10:end,1),init(1:10:end,2),init(1:10:end,3), 'bo', ...
            'Markersize', 10, 'MarkerFaceColor', [0 0.9 0]);
        xlabel('x'); ylabel('y'); zlabel('z'); title('Initial position');
        axis equal; grid on;

        figure;
        plot3(coords_r(1:100:end,1),coords_r(1:100:end,2), ...
            coords_r(1:100:end,3),'bo', 'Markersize', 12,  ...
            'MarkerFaceColor', [0 0 0.4]); hold on;
        plot3(alin(1:10:end,1),alin(1:10:end,2),alin(1:10:end,3), 'bo', ...
            'Markersize', 10, 'MarkerFaceColor', [0 0.9 0]);
        xlabel('x'); ylabel('y'); zlabel('z'); title('Final position');
        axis equal; grid on;
    end

    % Apply transformation to tensors
    fprintf('\nRotating %d Diffusion Tensors by C...\n',n_dat);

    tic;
    % Preallocate
    DT_r = zeros(size(DT));     % rotated diffusion tensors
    DT_rl = DT_r;               % rotated diffusion tensors, log transform
    indsrem = zeros(n_dat,1);   % indices of non-real diffusion tensors

    for j=1:n_dat;
        if mod(j,10000)==0
            fprintf('%.2f%% complete. %d tensors aligned\n',100*j./n_dat,j);
        end
        % Tensor (DT) transformation (rotation matrix only)
        DT_r(:,:,j) = C'*DT(:,:,j)*C;

        % Compute matrix logarithm of DT
        [DT_rl(:,:,j)] = logm(DT_r(:,:,j));
        if ~isreal(DT_rl(:,:,j))
            [DT_rl(:,:,j)] = real(logm(DT_r(:,:,j)));
            indsrem(j) = 1;           % mark data indices with nonreal tensors
            fprintf('*** Non-real tensor at index = %d ***\n',j);
        end
    end
    nnrdts = sum(indsrem);
    fprintf('There were %d non-real tensors.\n',nnrdts);
    toc;

    % Remove non-real tensors
    DT_rl = DT_rl(:,:,~indsrem);
    coords_r = coords_r(~indsrem,:);

    % Save workspace of aligned variables
    DTOutname = [DTfname(1:end-4) '_aligned.mat'];
    fprintf('\nSaving workspace variables as %s ...\n',DTOutname);
    tic;
        save([wd DTOutname],'DT_rl','coords_r');
    toc;

    fprintf('\nAll done!\n');

end % of function
