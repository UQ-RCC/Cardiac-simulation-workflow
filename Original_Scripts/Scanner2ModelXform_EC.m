function [] = Scanner2ModelXform_EC(wd,f_aligned, f_unaligned, DTfname,figyn)
%function [] = Scanner2ModelXform_EC(wd,f_aligned, f_unaligned, DTfname)
% This function computes/applies the transformation between DT-MR scanner 
% and geometric model coordinate frames. Since DT-MR is usually of lower 
% resolution than anatomical CT/MR scans, a geometric model is typically 
% constructed from the latter, and fiber information of the same heart but
% separate DT-MR scan is co-registered to the model in the simulation
% reference frame
%
% INPUTS:
% 1. wd - file path to working directory containing files below.
% 2. f_unaligned - OFF file containing (n_dat)x(3) point-cloud of 
%    coordinates in the anatomical scan reference frame
% 3. f_aligned - OFF file containing (n_dat)x(3) point-cloud of 
%    coordinates rotated to the model reference frame
% 4. DTfname - Matlab workspace containing variables DT and coords
%    generated by running Parse_AFNI_v3.m
% 5. figyn - 1 to show figures, 0 to not. Default is 0.
%
% OUTPUTS:
% 1. coords_r - (n_DTdat)x(3) array of DT-MR voxel coordinates 
%    rotated/co-registerd to anatomical model in model reference frame
% 2. DT_r - (n_DTdat)x(3)x(3) array of rotated diffusion tensors in model 
%    reference frame
% 3. DT_rl  - (n_DTdat)x(3)x(3) array of rotated matrix-log diffusion 
%    tensors in model reference frame
% 4. epr - (n_DTdat)x(3)x(3) array of rotated diffusion tensor eigenvalues
%    (should be the same as the unrotated ones...)
% 5. vpr - (n_DTdat)x(3)x(3) array of rotated diffusion tensor eigenvectors
%    in model reference frame
%
% Make sure to check that all input coordinates have CONSISTENT UNITS to 
% avoid scaling artifacts!
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Originally written by Chris Villongco
% Edited by Eric Carruth on 03/03/2017
% Last modified by Eric Carruth on 03/21/2017
% Contact: ecarruth@ucsd.edu OR kappyt3@gmail.com
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if nargin < 5
    figyn = 0;
end

% Read in the initial and aligned data sets
% Initial
fid = fopen([wd f_unaligned],'r');
ln0 = textscan(fid,'%s\n',1);
ln1 = textscan(fid,'%d\t%d\t%d\n',1);
npts_o = ln1{1};
init = textscan(fid,'%f\t%f\t%f\n',npts_o);
fclose(fid);
% Aligned
fid = fopen([wd f_aligned],'r');
ln0 = textscan(fid,'%s\n',1);
ln1 = textscan(fid,'%d\t%d\t%d\n',1);
npts_a = ln1{1};
alin = textscan(fid,'%f\t%f\t%f\n',npts_a);
fclose(fid);

init = cell2mat(init);
alin = cell2mat(alin);

load [wd DTfname] DT coords;

% Make sure they have the same number of vertices
if npts_o ~= npts_a
    error('The two input files have a different number of vertices!');
end

% Number of data points
n_dat = length(coords);

% Additional translation tweaks in blender to align DTMRI data to MRI data
% used for geometric fit
Tadj = ones(n_dat,1)*[0 0 0 0];

% Compute 4x4 transformation T
% Reference: http://www.euclideanspace.com/maths/geometry/affine/matrix4x4/
init(:,4) = 1;
alin(:,4) = 1;
T = (init'*init)\init'*alin;
fprintf('4x4 affine transformation matrix:\n');
disp(T);

% Extract rotation matrix from T
C = T(1:3,1:3);
fprintf('Tensor rotation matrix C:\n');
disp(C);

% Check that rotation does not include scaling. (det(C) should equal 1!)
fprintf('Determinant of C:\n');
disp(det(C));

% Apply transformation to coordinates
coords_temp = coords;
coords_temp(:,4) = 1;
coords_r = coords_temp*T + Tadj;
coords_r(:,4) = [];

% Get an equatorial slice
mx = max(coords_r(:,1));
mn = min(coords_r(:,1));
msl = (mx-mn)/2+mn; % middle of data
tmp = abs(coords_r(:,1) - msl); % How far from the middle in x?
[~,idx] = min(tmp); % Get the position of the closest point
slice = coords_r(idx,1); % Slice number of the closest point
% ind_slice = find(coords(:,1)==slice(1)); % Index of all at that x-value
ind_slice = find(abs(coords_r(:,1)-slice(1)) < 0.05);

% Show plots of original and rotated segmentation and coords
if figyn
    figure;
    plot3(coords(1:100:end,1),coords(1:100:end,2),coords(1:100:end,3), ...
        'bo','Markersize', 12, 'MarkerFaceColor', [0 0 0.4]); hold on;
    plot3(init(1:10:end,1),init(1:10:end,2),init(1:10:end,3), 'bo', ...
        'Markersize', 10, 'MarkerFaceColor', [0 0.9 0]);
    xlabel('x'); ylabel('y'); zlabel('z'); title('Initial position');
    axis equal; grid on;
    
    figure;
    plot3(coords_r(1:100:end,1),coords_r(1:100:end,2), ...
        coords_r(1:100:end,3),'bo', 'Markersize', 12,  ...
        'MarkerFaceColor', [0 0 0.4]); hold on;
    plot3(alin(1:10:end,1),alin(1:10:end,2),alin(1:10:end,3), 'bo', ...
        'Markersize', 10, 'MarkerFaceColor', [0 0.9 0]);
    xlabel('x'); ylabel('y'); zlabel('z'); title('Final position');
    axis equal; grid on;
    
    % Plot an equatorial slice
    figure;
    plot3(coords_r(ind_slice,1),coords_r(ind_slice,2), ...
        coords_r(ind_slice,3),'ko','MarkerFaceColor','b');
    axis equal; grid on;
    xlabel('x'); ylabel('y'); zlabel('z');
    
end

% Apply transformation to tensors
fprintf('\nRotating %d Diffusion Tensors by C...\n',n_dat);

tic;
% Preallocate
DT_r = zeros(size(DT));     % rotated diffusion tensors
DT_rl = DT_r;               % rotated diffusion tensors, log transform
vpr = DT_r;                 % rotated diffusion tensor eigenvectors
epr = zeros(n_dat, 3);      % rotated diffusion tensor eigenvalues
indsrem = zeros(n_dat,1);   % indices of non-real diffusion tensors

for j=1:n_dat;
    if mod(j,10000)==0
        fprintf('%.2f%% complete. %d tensors aligned\n',100*j./n_dat,j);
    end
    % Tensor (DT) transformation (rotation matrix only)
    DT_r(:,:,j) = C'*DT(:,:,j)*C;
    % Vector (coordinate) transformation
    % Eigenvalue decomposition
    [v,e] = eig_s(DT_r(:,:,j));
    % Eigenvectors
    vpr(:,:,j) = v;
    % Eigenvalues
    epr(j,:) = abs(diag(e))';
    % Compute matrix logarithm of DT
    [DT_rl(:,:,j)] = logm(DT_r(:,:,j));
    if ~isreal(DT_rl(:,:,j))
        [DT_rl(:,:,j)] = real(logm(DT_r(:,:,j)));
        indsrem(j) = 1;           % mark data indices with nonreal tensors
        fprintf('*** Non-real tensor at index = %d ***\n',j);
    end
end
nnrdts = sum(indsrem);
fprintf('There were %d non-real tensors.\n',nnrdts);
toc;

% Remove non-real tensors
DT_r = DT_r(:,:,~indsrem);
DT_rl = DT_rl(:,:,~indsrem);
vpr = vpr(:,:,~indsrem);
epr = epr(~indsrem,:);
coords_r = coords_r(~indsrem,:);
% Re-calculate the indices of the equatorial slice for rendering
ind_slice = find(abs(coords_r(:,1)-slice(1)) < 0.05);

% Save workspace of aligned variables
DToutname = [DTfname(1:end-4) '_aligned.mat'];
fprintf('\nSaving workspace variables as %s ...\n',DToutname);
tic;
save(DToutname,'DT_r','DT_rl','vpr','epr','coords_r');
toc;

% Save workspace of half of aligned variables (y-coord < 0, x > -2)
ind_half = coords_r(:,2) < 0 & coords_r(:,1) > -4;
DTouthalf = [DTfname(1:end-4) '_align_half.mat'];
fprintf('\nSaving workspace variables as %s ...\n',DTouthalf);
DT_rh = DT_r(:,:,ind_half);
DT_rlh = DT_rl(:,:,ind_half);
vprh = vpr(:,:,ind_half);
eprh = epr(ind_half,:);
coords_rh = coords_r(ind_half,:);
tic;
save(DTouthalf,'DT_rh','DT_rlh','vprh','eprh','coords_rh');
toc;

% Select equatorial slice for rendering in the model C.S.
renderoutname = 'alignedDTs.txt';
fprintf('\nGenerating DT rendering form as %s ...\n',renderoutname);
tic;
renderDTform(renderoutname,coords_r(ind_slice,:),epr(ind_slice,:), ...
    vpr(:,:,ind_slice));
% This could give an error if a lot of tensors were not real!
toc;

% Write out data file for Continuity to calculate Xi coordinates
fprintf('\nWriting data forms...\n');

% Get the number of points
npts = length(coords_rh);

% Define output data structure
header = ['coord1_val\tcoord1_weight\tcoord2_val\tcoord2_weight' ...
    '\tcoord3_val\tcoord3_weight\tLabel\tData\n'];
outdata = zeros(npts,8);
outdata(:,1) = coords_rh(:,1);
outdata(:,3) = coords_rh(:,2);
outdata(:,5) = coords_rh(:,3);
outdata(:,8) = (1:npts)';
o = ones(npts,1); % Make weights of all fitted coordinates 1.
[outdata(:,2),outdata(:,4),outdata(:,6)] = deal(o);

% Define output name
outname = 'cont_DT_coords_half.txt';

% Write output file
fid = fopen(outname,'wt');
fprintf(fid,header); % Write the header
fclose(fid);
% Append the data
dlmwrite(outname,outdata,'-append','delimiter','\t','precision',16);

% Confirm file was written
fprintf('File successfully written to %s\n',outname);

% Get the number of points
npts = length(coords_r);

% Define output data structure
header = ['coord1_val\tcoord1_weight\tcoord2_val\tcoord2_weight' ...
    '\tcoord3_val\tcoord3_weight\tLabel\tData\n'];
outdata = zeros(npts,8);
outdata(:,1) = coords_r(:,1);
outdata(:,3) = coords_r(:,2);
outdata(:,5) = coords_r(:,3);
outdata(:,8) = (1:npts)';
o = ones(npts,1); % Make weights of all fitted coordinates 1.
[outdata(:,2),outdata(:,4),outdata(:,6)] = deal(o);

% Define output name
outname = 'cont_DT_coords_mask_aligned.txt';

% Write output file
fid = fopen(outname,'wt');
fprintf(fid,header); % Write the header
fclose(fid);
% Append the data
dlmwrite(outname,outdata,'-append','delimiter','\t','precision',16);

% Confirm file was written
fprintf('File successfully written to %s\n',outname);

fprintf('\nAll done!\n');

end % of function